lesson1 = standard output 
lesson2 = variable & data type
lesson3 = namespace
lesson4 = typedef
lesson5 = type conversion/casting
lesson6 = User Input
lesson7 = Math Related Functions
lesson8 = If Statement
lesson9 = Switch
lesson10 = Ternary Operator
lesson11 = String Methods
lesson12 = While Loop & Do While Loop
lesson13 = For Loop & Break & Continue
lesson14 = Random Number
lesson15 = Function
lesson16 = Array
lesson17 = sizeof()
lesson18 = Iterate an Array & Pass an array to a function
lesson19 = Bubble Sort
lesson20 = Fill()
lesson21 = 2D Array
lesson22 = Memory Address & Pass by Value vs Reference vs Pass Reference
lesson23 = Pointer & Null Pointer
lesson24 = Dynamic Memory
lesson25 = Recursion
lesson26 = Function Template
lesson27 = Struct & Pass Struct as argument
lesson28 = Enum
lesson29 = OOP (+ constructor, overloaded constructor, abstraction, inheritance)
lesson30 = Vector Function
lesson31 = std::sort
lesson32 = Type Casting
lesson33 = Pair
lesson34 = std::priority_queue
lesson35 = std::deque
lesson36 = std::stack
lesson37 = std::queue
lesson38 = std::list
lesson39 = std::map


Next Lessons: (Refer to: https://chatgpt.com/c/6768ea82-0b98-8005-b8e6-c4c06f9627ac)
- Lambda expressions
- const auto
- decltype
- Custom Structure implementation (struct)
- review Enum & other things you forgot
- Hashmap
- This problem is a minimum vertex cover in a bipartite graph, 
which can be solved using KÃ¶nig's theorem or by using a maximum matching algorithm.
- Tarjan's strongly connected component algorithm
- Permutation & Combination
- How did euler find Euler path and circuit theorem?
- std::set, std::multiset, std::map, std::multimap
- LCRS implementation. (Real tree)

- Create binary tree using class. Refer to linkedlist.
- Which one's better? using struct or class? How to free memory in Tree? It's either BFS or DFS. Traverse, then delete.
- Free memory of tree in all files, including UNNC.
- bool operator() inside struct and any other shit. e.g








DIJKSTRA
Label your vertex visited.
Start with 0 cost for current vertex
List all the vertex's possible destination. 
Go to each destination
Record the cost for each possible destination. Compare to the past cost.

Find the smallest cost of destination using priority queue (I guess)
Change the current vertex to that destination.

Repeat the process until the final destination is reached.
Then, retrace all the path backwards. (Explain more in detail later)

PRIMS
find the smallest edge.



